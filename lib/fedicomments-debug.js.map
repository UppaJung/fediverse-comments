{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import type {Status} from \"./MastodonApiV1Entities.ts\";\n\ninterface StatusQuery {\n  host: string;\n  status: string;\n}\n\ninterface ContextResponseJson {\n  ancestors: Status[];\n  descendants: Status[];\n}\n\nconst DataAttributes = ['host', 'status', 'statusUrl', 'include', 'exclude', 'max',  'hideRootStatus', 'display'] as const;\ntype RootDataAttribute = NonNullable<(typeof DataAttributes)[number]>;\n\ntype RootElementDataAttributes = Partial<Record<RootDataAttribute, string>>;\n\nconst fetchJson = async <T>(...args: Parameters<typeof fetch>): Promise<T> => {\n    const response = await fetch(...args);\n    if (!response.ok) {\n        throw new Error(response.statusText);\n    }\n    return await response.json() as T\n}\n\nconst fetchContext = ({host, status}: StatusQuery) =>\n  fetchJson<ContextResponseJson>(`https://${host}/api/v1/statuses/${status}/context?limit=1`, {});\n\nconst fetchStatus = async ({host, status}: StatusQuery) =>\n  fetchJson<Status>(`https://${host}/api/v1/statuses/${status}, {});`);\n\n// Should take query of the form:\n// https://mastodon.social/@MildlyAggrievedScientist/110826278791052494\n// So that users can just paste URLs\nconst urlToStatusQuery = (statusUrl: string): StatusQuery => {\n const {host, pathname} = new URL(statusUrl);\n const status = pathname.split('/')[2] ?? \"\";//.filter( s => s.length > 0 && !s.startsWith('@') );\n return {host, status}\n}\n\nconst fetchStatusAndReplies= async (statusQuery: StatusQuery | string) => {\n const query = (typeof statusQuery === \"string\") ? urlToStatusQuery(statusQuery) : statusQuery; \n const [status, context] = await Promise.all([fetchStatus(query), fetchContext(query)]);\n return [status, ...context.descendants];\n}\n\nconst eventTargetToDataElement = (target: EventTarget | null, dataElement: string): string | undefined => {\n  var value: string | undefined;\n  while (value == null && target instanceof Element) {\n    if (target instanceof HTMLElement) {\n      value = target.dataset[dataElement];\n      if (value != null) {\n        return value;\n      }\n    }\n    target = target.parentElement;\n  }\n}\nexport const eventTargetToResponseUrl = (target: EventTarget | null): string | undefined =>\n  eventTargetToDataElement(target, \"responseUrl\");\nexport const eventTargetToRootCommentUrl = (target: EventTarget | null): string | undefined =>\n  eventTargetToDataElement(target, \"rootCommentUrl\");\n\n/**\n * \n * @param rootCommentElement \n * @returns \n * \n * Uses node.clone to create each comment, so inline event listeners on those comments (onclick=\"...\") will be copied,\n * but event listeners added via addEventListener() will not.  One could add those after the fact by querying all\n * the comments. \n */\nconst loadCommentsIntoDom = async (rootCommentElement: HTMLElement) => {\n  // extra data from data attributes\n  const dataAttributes = ((rootCommentElement as HTMLElement)?.dataset ?? {}) as RootElementDataAttributes;\n  const includeSet = new Set<string>((dataAttributes.include ?? \"\").split(',').map(e => e.trim()));\n  const excludeSet = new Set<string>((dataAttributes.exclude ?? \"\").split(',').map(e => e.trim()));\n  const maxResponses = parseInt(dataAttributes.max ?? \"\");\n  const statusUrl = dataAttributes[\"statusUrl\"];\n  const {host, status} =  statusUrl != null ? urlToStatusQuery(statusUrl) : dataAttributes;\n\n  // ensure there is at least a host and status, either from data-host/data-status or extracted from data-status-url\n  if (host == null || status == null) return;\n\n  // filter excluded responses out\n  const comments = (await fetchStatusAndReplies({host, status}))\n    .filter( r => !excludeSet.has(r.id) );\n  \n  // filter out responses that exceed length limit (though scrolling is recommended instead)\n  if (!isNaN(maxResponses)) {\n    for (var i = comments.length-1; i > 0 && comments.length > maxResponses; i--) {\n      if (!includeSet.has(comments[i].id)) {\n        comments.splice(i, 1);\n      }\n    }\n  }\n\n  // create a map from each comment status id to the DOM element that will hold\n  // its replies\n  const statusIdToElementContainingItsReplies = new Map<string, Element>();\n\n  // create a DOM template for each response comment by cloning the root comment\n  const responseTemplate = rootCommentElement.cloneNode(true) as typeof rootCommentElement;\n\n  // remove data specified for the root comment from the template\n  for (const dataAttribute of DataAttributes) {\n    delete responseTemplate.dataset[dataAttribute]\n  }\n\n  // loop through all response comments to add them\n  for (const comment of comments) {\n    // clone the template to create the element that will hold this response\n    const commentElement = status === comment.id ? rootCommentElement : responseTemplate.cloneNode(true) as typeof rootCommentElement;\n\n    // isolate the child elements for the comments's author, content, and child replies\n    const authorElement = commentElement.querySelector('[data-response-type=author], .response-author');\n    const authorDisplayNameElement = commentElement.querySelector('[data-response-type=author-name], .response-author-name');\n    const authorFullHandleElement = commentElement.querySelector('[data-response-type=author-handle], .response-author-handle');\n    const contentElement = commentElement.querySelector('[data-response-type=content], .response-content');\n    const repliesToThisResponseElement = commentElement.querySelector('[data-response-type=replies], .response-replies');\n    if ((!authorElement && (!authorDisplayNameElement || !authorFullHandleElement)) || !contentElement || !repliesToThisResponseElement) return;\n\n    // create the author content\n    const {account} = comment;\n    const {hostname} = new URL(account.url);\n\n    const authorHandleNameElement = document.createElement('a');\n    authorHandleNameElement.classList.add('fediverse-handle-name');\n    authorHandleNameElement.setAttribute('href', account.url);\n    authorHandleNameElement.setAttribute('target', '_blank');\n    authorHandleNameElement.textContent = `@${account.username}`;\n    \n    const authorHandleHostSpan = document.createElement('span');\n    authorHandleHostSpan.classList.add('fediverse-host-name');\n    authorHandleHostSpan.textContent = `@${hostname}`;\n\n    if (authorDisplayNameElement) {\n      authorDisplayNameElement.textContent = comment.account.display_name;\n    } else if (authorElement) {\n      authorElement.textContent = `${comment.account.display_name} `;\n    }\n    if (authorFullHandleElement) {\n        authorFullHandleElement.appendChild(authorHandleNameElement);\n        authorFullHandleElement.appendChild(authorHandleHostSpan);\n    } else if (authorElement) {\n      authorElement.appendChild(authorHandleNameElement);\n      authorElement.appendChild(authorHandleHostSpan);\n    }\n\n    // copy the content element (non-sanitized, since we're trusting the host server to sanitize it)\n    // if we wanted to sanitize, we could use the [HTML Sanitizer API](https://wicg.github.io/sanitizer-api/),\n    // or [DOMPurify](https://github.com/cure53/DOMPurify/) until there is full browser support for the\n    // the sanitizer API.\n    contentElement.innerHTML = comment.content; // NOT sanitized since I'm trusting server to do so.\n\n    // into each element, we will copy a data attribute that allows event handlers to get the\n    // response's ID and URL.\n    for (const e of [authorElement, authorDisplayNameElement, authorFullHandleElement, contentElement, repliesToThisResponseElement, commentElement]) {\n      if (e != null) {\n        e.setAttribute('data-response-id', comment.id);\n        e.setAttribute('data-response-url', comment.url ?? \"\");\n      }\n    }\n\n    // set the mapping from this response's status ID to its reply element so that replies\n    // can append themselves to the reply-chain.\n    statusIdToElementContainingItsReplies.set(comment.id, repliesToThisResponseElement);\n    \n    if (commentElement !== rootCommentElement && comment.in_reply_to_id) {\n      statusIdToElementContainingItsReplies.get(comment.in_reply_to_id)?.appendChild(commentElement);\n    }\n  }\n}\n\nconst findCommentTemplatesAndLoadCommentsIntoDom = () => {\n  const commentElements = document.querySelectorAll('[data-host][data-status], [data-status-url]');\n  for (const templateElement of commentElements) {\n    if (templateElement instanceof HTMLElement) {\n      loadCommentsIntoDom(templateElement);\n    }\n  }  \n}\n\ndocument.addEventListener('DOMContentLoaded', findCommentTemplatesAndLoadCommentsIntoDom);\n"],
  "mappings": "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",
  "names": []
}
